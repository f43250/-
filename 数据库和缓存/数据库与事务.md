# 数据库与事务

## 数据库设计三范式
 - 第一范式: 每一列都是最小单位,不可在拆分.
 - 第二范式: 每一列要有一个唯一标识,一般是主键
 - 第三范式: 每一列都和主键直接相关,而不是间接相关(外键除外)
 
  `说明:` 并不是好的数据库设计一定要遵循三范式.有的时候设计冗余字段可以减少表关联
  
## 乐观锁和悲观锁
 - 乐观锁: 觉得每次拿数据的时候没有被其他人修改,所以不上锁,由版本号实现
 - 悲观锁: 觉得每次拿数据都被别人修改了 `forUpdate`

## 存储引擎
 - Myisam: 适合读取频繁读取的表,支持表锁
 - Innodb: 适合修改频繁的表(`默认`),支持表锁和行锁
## mysql性能优化相关
1. 建立合适的索引
2. 避免使用select *
3. 选择正确的存储引擎
4. 垂直/水平分表
5. 读写分离
6. 避免连接三张以上的表
7. 硬件升级
## 1. 事务的ACID
| 类型 | 特点 | 
| ---- | ---- |
| 原子性 | 一个事务中的操作要么全部成功,要么全部失败 | 
| 一致性 | 执行事务前后数据库的完整性没有被破坏 | 
| 隔离性 | 两个事务互相独立,不知道其他事务内容 |
| 持久性 | 事务完成后,数据持久化. |

## 2.事务的隔离级别
| 级别 | 特点 | 说明|
| ---- | ---- | ---- |
| READ_UNCOMMITTED | 读未提交，即能够读取到没有被提交的数据， | 无法解决脏读、不可重复读、幻读
| READ_COMMITED(`PG,Oracle默认`) | 读已提交，即能够读到那些已经提交的数据 | 能够防止脏读，但是无法限制不可重复读和幻读
| REPEATABLE_READ(`MySql默认`) | 读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，| 但是幻读的问题还是无法解决
| SERLALIZABLE | 不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务 | 串行化执行|

## 3.影响

| 类型 | 特点 | 
| ---- | ---- |
| 脏读 | 一个事务读取到其他事务还未提交的数据 | 
| 不可重复读 | 一个事务多次读取,结果不一样 | 
| 幻读 | 一个事务在前后两次查询,发现了不一样的行. |

## 4.spring事务的实现方式
 - 1. 编程式事务
 - 2. 基于注解的声明式事务
 - 3. 基于AOP的事务
 - 4. 基于TransactionProxyFactoryBean