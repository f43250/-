# 数据库与事务

## 数据库设计三范式
 - 第一范式: 每一列都是最小单位,不可在拆分.
 - 第二范式: 每一列要有一个唯一标识,一般是主键
 - 第三范式: 每一列都和主键直接相关,而不是间接相关(外键除外)
 
  `说明:` 并不是好的数据库设计一定要遵循三范式.有的时候设计冗余字段可以减少表关联
  
## 数据库锁
 - 按照模式分类:
   - 乐观锁: 觉得每次拿数据的时候没有被其他人修改,所以不上锁,由时间戳或版本号实现
   - 悲观锁: 觉得每次拿数据都被别人修改了 `forUpdate`
 - 按照粒度分类
   - 全局锁(场景:全库逻辑备份)
   - 表级锁(并发低 不会出现死锁; Innodb:不走索引会走全表扫描.针对非索引列)
   - 页级锁(BDB引擎,一次锁定相邻的一组记录)
   - 行级锁(Innodb:给索引上的索引项加锁实现,最容易死锁)
 - 按属性分类:
   - 共享锁(S锁: select ... lock in share mode)
   - 排他锁(X锁: select ... for update)
 - 按意向分类:
   - 意向共享锁:(事务有意向加S锁,需要先获取IS锁)
   - 意向排他锁:(事务有意向加S锁,需要先获取IX锁)
 - 按算法分类(都属于排他锁,使用for update):
   - 间隙锁:(RR级别解决幻读:封锁索引记录中的间隔,锁定的是B+树叶子节点的next指针,封锁范围为范围查询左开右闭区间)
   - 记录锁:(封锁记录行)
   - 临键锁:(间隙锁+记录锁的组合,封锁范围既包含索引记录,也包含索引区间.)

## 存储引擎
 - Myisam: 适合读取频繁读取的表,支持表锁
 - Innodb: 适合修改频繁的表(`默认`),支持表锁和行锁

## mysql性能优化相关
1. 建立合适的索引
2. 避免使用select *
3. 选择正确的存储引擎
4. 垂直/水平分表
5. 读写分离
6. 避免连接三张以上的表
7. 硬件升级

## 索引
- 什么是索引: 索引其实是一种数据结构,能够帮助我们快速检索数据库中的数据结构
- 索引结构及类型:
  - 存储结构区分 
    - Hash索引:`无法进行范围查询或者排序`
    - B+Tree索引
      - 聚簇索引:INNODB `逻辑结构顺序与数据存储物理结构顺序一致的一种索引，并且一个表的聚簇索引只能有唯一的一条`
      - 非聚簇索引:MyISAM `非聚簇索引记录的逻辑结构顺序与数据存储物理结构顺序没有必然的联系，与数据的存储物理结构没有关系,非聚簇索引可以有多条`
  - 逻辑区分: 
    - 普通索引: 加快访问速度,允许重复和空 `INDEX`
    - 主键索引: 专门为主键字段创建的索引,不允许重复或者空 `PRIMARY KEY `
    - 唯一索引: 保证数据唯一性,允许空 `UNIQUE`
    - 全文索引: 保证数据唯一性,允许重复和空 `GEOMETRY`
    - 空间索引: 保证数据唯一性,不允许空 `FULLTEXT`
- 联合索引:
  1. 遵循最左匹配原则
  2. 遇到范围查询停止匹配
  3. 联合索引为a,b,查询条件为b=x,a=y可以用到索引吗?`可以`,mysql会将查询条件顺序调整为(a,b)

- 相关问题
  1. 什么是回表查询?
     - 非主键索引查询时需要先查询到主键,再通过主键查询到具体数据
  2. 如何避免?
     - 将查询条件的字段都加入到联合索引里面. 
  3. 如何判断索引被使用了?
     - show status like 'Handler_read%';  

## MySql为什么使用B+树而不适用其他树?
- 树比较
  - 二叉树: 某些情况下会退化为线性结构,让时间复杂度变为O(n)
  - AVL树: 旋转耗时
  - 红黑树: 树的深度过大会造成磁盘读写频繁.
  - B树: B树节点既存储索引又存储数据,不支持顺序查找,B树范围查找要先找到下限,然后进行中序遍历
  - B+树: B+树只有叶子节点存储数据.更适合范围查找,用链表串联起来就可以顺序遍历查找,查询时间复杂度为O(logn).所以B+树的IO次数更少.
- `衡量查询效率指标:磁盘读写次数`


## 1. 事务的ACID
| 类型 | 特点 | 
| ---- | ---- |
| 原子性 | 一个事务中的操作要么全部成功,要么全部失败 | 
| 一致性 | 执行事务前后数据库的完整性没有被破坏 | 
| 隔离性 | 两个事务互相独立,不知道其他事务内容 |
| 持久性 | 事务完成后,数据持久化. |

## 2.事务的隔离级别
| 级别 | 特点 | 说明|
| ---- | ---- | ---- |
| READ_UNCOMMITTED | 读未提交，即能够读取到没有被提交的数据， | 无法解决脏读、不可重复读、幻读
| READ_COMMITED(`PG,Oracle默认`) | 读已提交，即能够读到那些已经提交的数据 | 能够防止脏读，但是无法限制不可重复读和幻读
| REPEATABLE_READ(`MySql默认`) | 读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，| 但是幻读的问题还是无法解决
| SERLALIZABLE | 不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务 | 串行化执行|

## 3.影响

| 类型 | 特点 | 
| ---- | ---- |
| 脏读 | 一个事务读取到其他事务还未提交的数据 | 
| 不可重复读 | 一个事务多次读取,结果不一样 | 
| 幻读 | 一个事务在前后两次查询,发现了不一样的行. |

## 4.spring事务的实现方式
 - 1. 编程式事务
 - 2. 基于注解的声明式事务
 - 3. 基于AOP的事务
 - 4. 基于TransactionProxyFactoryBean