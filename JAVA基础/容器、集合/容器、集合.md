# 集合
![集合框架](/静态资源/List和Map.png )

## 一. Collection接口

  - Collection:
    - List: 有序可重复
      - ArrayList: 线程不安全,数组,查询时间复杂度o(1),支持快速随机访问(通过数组下标),每次扩容为原来的1.5倍
      - LinkedList: 线程不安全,双向链表,增删快.查询时间复杂度o(n)
      - Vector: 线程安全,每次扩容为原来的2倍
        - Stack: LIFO 
    - Set: 无序不可重复
      - HashSet: 内部HashMap保证不可重复
        - LinkedHashSet: 内部LinkedHashMap保证不可重复
      - TreeSet: 红黑树,自然排序或比较器排序
      - EnumSet: 专为枚举准备
    - Queue: FIFO

## 二. Map接口
  - Map:
    - HashMap: key不可重复的KV对,线程不安全,基于hash表.初始容量16 
      - LinkedHashMap: HashMap+双向链表 插入或者访问排序
    - HashTable: 线程安全,基于hash表,扩容为2N+1
      - Properties: 读取环境变量或者文件属性等 
    - IdentityHashMap: 允许容器以地址去重,而不是以hashcode
    - WeakHashMap: 弱引用 场景:线程安全的LRU缓存
    - EnumMap: 用于枚举
    - TreeMap:  基于红黑树,自然排序或比较器排序

- `1.null情况`
  - HashMap: key和value均可以为null,key为null时hashcode为0
  - HashTable: key和value不能为null,默认容量11
  - CurrentHashMap: key和value不能为null
    - 原因: HashTable和CurrentHashMap支持并发,获取key出来为null不能分别是没有做过映射还是手动put的null值.

- `2.HashTable和CurrentHashMap为什么支持并发`
  - HashTable:所有方法被Synchronized修饰
  - CurrentHashMap:
    - JDK1.7:分段锁,Segment继承自ReentrantLock可以重入类
    - JDK1.8:CAS(延伸ABA问题) + Synchronized
  
- `3.如何创建线程安全的List和Map`
  - List: 
    -  Collections.synchronizedList(): 重写一些例如add的方法,添加Synchd关键字
    -  CopyOnWriteArrayList: 修改操作时加锁用新集合替换
  - Map: Collections.synchronizedMap()和ConCurrentHashMap
    - Collections.synchronizedMap(): Synchronized关键字
    - ConCurrentHashMap: 分段锁/CAS
  
- `4.Java集合的快速失败机制 “fail-fast`
  - 假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。因为检测了modCount.
  - 解决: 
    - 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。
    - 使用CopyOnWriteArrayList来替换ArrayList

- `5.如何一边遍历一边删除`
  - Iterator.remove() 