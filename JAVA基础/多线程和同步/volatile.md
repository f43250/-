##volatile

####作用
(1)保证线程间可见性,但不能保证原子性.(并发三性:可见性,顺序性,原子性)


(2)防止指令重排.


######总结
1.为什么不加volatile,一个线程改变变量,其他线程不可见?

    不同线程使用同一个变量,每个线程会从主存中拷贝一份到线程私有区域(虚拟机栈)的CPU高速缓存.每个线程修改只改变了自己虚拟机栈的副本,
    而主存和其余线程虚拟机栈中的副本没有被改变.


2.volatile如何保证线程间可见?

    每个线程改变自己虚拟机栈的变量副本后,强制写入主存(线程共享),然后让其余线程虚拟机栈的副本失效(告诉过期),让其余线程读取此变量时
    强制从主存中读取(同时刷新自己虚拟机栈的CPU高速缓存副本).
    
    
3.什么是指令重排

    cpu会为了性能,打乱和优化指令.例如.
    ①int a=1;
    ②int b=2;
    ③int c= a+b;
    ①和②交换顺序并不会影响结果.
    
    但实例化一个对象的过程却会影响 Value value = new Value();
    ④memory = allocate(); // 内存空间划分
    ⑤init(); // 初始化
    ⑥value = memory; // 变量赋值
    此时⑤和⑥不能交换顺序,否则value为空.

4.volatile如何防止指令重排
    
    内存屏障,使用lock指令,犹如在⑤和⑥之间生成了一道墙防止⑤和⑥指令重排.
    
5.volatile为什么不能保证原子性
    
    例如两个线程都对一个变量执行自增,自增分为三步①获取值 ②自增值 ③写入缓存.假如线程A获取值100后阻塞,线程B获取值100后,自增到
    101写入缓存,线程A获取值操作已经结束,线程A开始执行100自增到101写入缓存而不是101自增到102写入缓存,所以加了volatile也无用.
    
6.原子类如何保证原子性的  

    Unsafe类与CAS.CAS无法避免ABA问题.
   