# Synchronized

## 1.位置与区别
| 修饰区域 | 含义 |
| ---- | ---- |
| 修饰静态方法 | 整个静态方法，作用的对象是这个类的所有对象 |
| 修饰普通方法或者`this` | 作用的对象是调用这个方法的对象,不同线程调用同一个对象的同步方法会被锁住
| 代码块 | 调用这么代码块的对象 |
| 类对象 | 这个类的所有对象 |

## 2.synchronized 和 volatile 可以保证原子性吗?
 - volatile: 告诉JVM当前变量的值是不确定的,从主存中读取,只能保证可见性,不能保证原子性.
   - 可见性: 每个线程改变自己虚拟机栈的变量副本后,强制写入主存(线程共享),然后让其余线程虚拟机栈的副本失效(告诉过期),让其余线程读取此变量时
    强制从主存中读取(同时刷新自己虚拟机栈的CPU高速缓存副本).
 - synchronized: 
   - 原子性:加锁后其他线程无法获取锁,就算cpu时间片用完,由于是可冲入锁,下一个时间片还是只有被他自己获取.
   - 有序性:由于只能被单线程访问,只能顺序执行
   - 可见性:
     - 线程加锁前:清空工作内存的变量值,从而使其他线程读取变量需要冲主存中读取
     - 线程解锁前:讲共享变量最新值刷入主存.